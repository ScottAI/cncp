# postprocessing.py

# A collection of functions for post-processing HTML files
# generated from IPython notebooks for publication on the
# web or as an EPUB ebook

from bs4 import BeautifulSoup
import re
import sys
import os
import base64
import subprocess 


def extras( doc ):
    """Return the name of the directory associated with
    "extra" files generated by post-processing"""
    fn = doc['filename']
    return os.path.splitext(os.path.basename(fn))[0] + '_files'


def remove_extraneous_characters( doc ):
    """Remove any extranenous characters like pilcrows after titles"""

    # pilcrows
    pilcrows = doc.find_all(text = '&#182;')
    for p in pilcrows:
        b = p.replace('&#182;', '')
        p.replace_with(b)


def remove_scripts( doc ):
    """Remove references to Javascript"""
    scripts = doc('script')
    for elem in scripts:
        elem.extract()


def remove_styling( doc ):
    """Remove CSS styling"""

    # style sheet references
    stylesheets = doc('link', rel='stylesheet')
    for elem in stylesheets:
        elem.extract()

    # inline styles
    styling = doc('style')
    for elem in styling:
        elem.extract()


def rewrite_mathjax( doc ):
    """Rewrite to the correct Mathjax CDN URL. It seems to have moved
    from the version built-in to IPython."""
    mathjax = re.compile("/mathjax/")
    scripts = doc('script', src = mathjax)
    for script in scripts:
        script['src'] = 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'


def rewrite_internotebook_links( doc ):
    """Re-write inter-notebook links resolved via the IPython notebook
    server into links to the corresponding generated HTML files"""
    ipynb = re.compile("([^\.]+).ipynb(#.*)?")
    links = doc('a', href = ipynb)
    for elem in links:
        m = re.match(ipynb, elem['href'])
        if m != None:
            elem['href'] = m.group(1) + ".html"
            if m.group(2) is not None:
                # link has an anchor, add it too
                elem['href'] = elem['href'] + m.group(2)


def rewrite_internotebook_links_flat( doc ):
    """Re-write linkes between notebooks to respect the flat file structure
    used for (for example) EPUB."""
    ipynb = re.compile("([^\.]+).ipynb(#.*)?")
    links = doc('a', href = ipynb)
    for elem in links:
        m = re.match(ipynb, elem['href'])
        if m is not None:
            if m.group(2) is not None:
                # link is to an explicit anchor in a notebook, which
                # will now be in this document since we're flat, so jump directly
                elem['href'] = m.group(2)
            else:
                # link is to a notebook, convert to a chapter-heading link
                elem['href'] = "#chap-" + m.group(1)


def rewrite_title( doc ):
    """Re-write the title of a document to use the same text
    as the first H1 element"""

    title = doc.title
    h1 = doc.h1
    if not ((h1 is None) or (title is None)):
        # new title is the initial text of the first h1
        title.string = h1.text
        

def rewrite_embedded_media( doc ):
    """Re-write any embedded media into external files that can
    be loaded directly"""
    data_url = re.compile('data:([^;]+);([^,]+),(.+)$', re.MULTILINE + re.DOTALL)
    for elem in doc('img', src = re.compile("data:")):
        m = data_url.match(elem['src'])
        # sd: do we need to handle MIME types other than image/png?
        s = next_sequence_number()
        image_fn = os.path.join(doc['extras_build_directory'],
                                "img-" + str(s) + ".png")
        with open(image_fn, "wb") as img:
            img.write(base64.b64decode(m.group(3)))

        # re-write to generated file
        image_ref = os.path.join(doc['extras_directory'],
                                 "img-" + str(s) + ".png")
        elem['src'] = image_ref


def run_shell_command( cmd ):
    """Run a shell command silently, failing if it does"""
    with open("/dev/null", 'w') as devnull:
        subprocess.check_call(cmd, stdout = devnull,
                                   stderr = subprocess.STDOUT,
                                   shell = False)


def rewrite_embedded_maths( doc ):
    """Re-write any embedded equations as images that are then
    linked to"""
    inline_mode = re.compile(r'[$](.*?)[$]')
    block_mode = re.compile(r'[$][$](.*?)[$][$]', re.DOTALL)
    align_mode = re.compile(r'(\\begin{align\*?}.*?\\end{align\*?})', re.DOTALL)

    rewrite_embedded_maths_formulae(doc, align_mode, 'display-maths', mathsbrackets = False)
    rewrite_embedded_maths_formulae(doc, block_mode, 'display-maths')
    rewrite_embedded_maths_formulae(doc, inline_mode, 'inline-maths')


def rewrite_embedded_maths_formulae( doc, mode, cl, mathsbrackets = True ):
    """Run through the document replaing formulae that match the given re."""
    maths = doc(text = mode)
    for para in maths:
        # extract the formulas
        newpara = para.string
        fs = mode.findall(para)
        if fs:
            for f in fs:
                # generate an image to replace the maths
                fo = f
                if mathsbrackets:
                    fo = "\ensuremath{{{formula}}}".format(formula = fo)
                fn = layout_maths(doc, fo)

                # insert an image tag in place of the formula
                newpara = layout_maths_image(doc, mode, newpara, f, fn, cl)

            # re-interpret the adjusted paragraph to build a new model
            t = BeautifulSoup(newpara).body.contents[0]
            if t.name != 'img':
                t.name = 'span'    # replace 'contentful' tag with something anodyne
            para.replace_with(t)


def next_sequence_number():
    """A sequence of numbers for unique filename generation."""
    s = next_sequence_number.sequence_number
    next_sequence_number.sequence_number += 1
    return s
next_sequence_number.sequence_number = 1


def layout_maths_image( doc, mode, para, f, fn, cl ):
    """Replace a formula with an image tag of the appropriate class."""
    if fn is not None:
        newpara = mode.sub("<img class=\"" + cl + "\" src=\"" + fn + "\"/>", para, count = 1)
    else:
        newpara = mode.sub("(Problem formula: " + f + ")", para, count = 1)
    return newpara


def layout_maths( doc, f ):
    """Use LaTeX to layout a formula and convert to a PNG image, returning
    the relative filename to use in the img tag that refers to it."""

    # set up the intermediate files
    s = next_sequence_number()
    tmp = "tmp-" + str(os.getpid()) + "-" + str(s)
    latex_fn = tmp + ".tex"
    aux_fn = tmp + ".aux"      # temp file generated by latex
    log_fn = tmp + ".log"      # temp file generated by latex
    dvi_fn = tmp + ".dvi"
    eps_fn = tmp + ".eps"
    png_ref = os.path.join(doc['extras_directory'],
                           "formula_" + str(s) + ".png")
    png_fn = os.path.join(doc['extras_build_directory'],
                          "formula_" + str(s) + ".png")

    # create a LateX file containing just the formula within a
    # standalone document
    with open(latex_fn, "wb") as tmp:
        print >>tmp, '\\documentclass[varwidth]{{standalone}}\n\usepackage{{amsmath}}\n\usepackage{{amssymb}}\n\\begin{{document}}\n{formula}\n\\end{{document}}\n'.format(formula = f)

    # run the necessary LaTeX tools on the generated document to 
    # create a PNG for the formula
    try:
        run_shell_command(["latex", "-interaction=nonstopmode", latex_fn])
        run_shell_command(["dvips", "-E", "-o", eps_fn, dvi_fn])
        run_shell_command(["convert", "-density", str(120), eps_fn, png_fn])
    except Exception as ex:
        # Leave unchanged if we had a problem with conversion
        print "Problem converting " + f + ": " + str(ex)
        png_ref = None

    # remove the intermediate files, leaving just the image
    for fn in [latex_fn, aux_fn, log_fn, dvi_fn, eps_fn]:
        try:
            os.remove(fn)
        except Exception:
            # don't worry about missing files
            pass

    return png_ref


def open_html( fn, dir ):
    """Open an HTML document, returning it as an object"""

    # ingest the source file, recording its attributes
    doc = BeautifulSoup(open(fn), "html.parser")
    doc['filename'] = fn

    # create the build directory structure
    doc['build_directory'] = dir
    doc['extras_directory'] = extras(doc)
    extras_build_dir = os.path.join(doc['build_directory'],
                                    doc['extras_directory'])
    if not os.path.exists(extras_build_dir):
        os.mkdir(extras_build_dir)
    doc['extras_build_directory'] = extras_build_dir

    return doc


def write_html( doc ):
    """Write the modified document out to standard output"""
    source_fn = doc['filename']
    build_dir = doc['build_directory']
    fn = os.path.join(build_dir, source_fn)
    with open(fn, 'wb') as gen:
        print >>gen, str(doc)    # doc.prettify(formatter = 'html')

